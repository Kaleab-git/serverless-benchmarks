import os
import uuid
import subprocess
from . import storage
import logging
import shutil

XC_ENC_REBASE = "/tmp/xc-enc -W -w 0.75 -i y4m -o {output}.ivf -r -I {source_state}.state -p {input_pred}.ivf -S {pred_state}.state {extra} {input}.y4m"

client = storage.storage.get_instance()

def download_bin(bucket, name, dest_dir):
    path = os.path.join(dest_dir, name)
    if not os.path.exists(path):
        client.download(bucket, name, path)
        subprocess.check_output(f"chmod +x {path}", stderr=subprocess.STDOUT, shell=True)


def upload_files(bucket, paths):
    for path in paths:
        file = os.path.basename(path)
        print("Uploading", file, "to", path)
        client.upload(bucket, file, path, unique_name=False)


def run(cmd):
    try:
        return subprocess.check_output(cmd, stderr=subprocess.STDOUT, shell=True)
    except subprocess.CalledProcessError as e:
        logger = logging.getLogger()
        logger.error(f"Error when executing command: {cmd}\n{e.output.decode('utf-8')}")
        raise e


def prev_seg_name(seg):
    idx = int(seg)-1
    assert(idx >= 0)
    return "{:08d}".format(idx)


def rebase(segs, data_dir, dry_run=False):
    input_paths = []
    output_paths = []

    for idx in range(2, len(segs)):
        name = segs[idx]
        input_path = os.path.join(data_dir, name)
        prev_input_path = os.path.join(data_dir, prev_seg_name(name))
        source_state_path = f"{prev_input_path}-1"
        output_state_path = f"{input_path}-1.state"
        extra = f"-O {output_state_path}" if idx != len(segs)-1 else ""
        input_pred_path = f"{input_path}-1"
        pred_state_path = f"{prev_input_path}-0"

        cmd = XC_ENC_REBASE.format(
            output=input_path,
            input=input_path,
            source_state=source_state_path,
            extra=extra,
            input_pred=input_pred_path,
            pred_state=pred_state_path)
        if not dry_run:
            run(cmd)

        input_paths.append(input_path+".y4m")
        input_paths.append(source_state_path+".state")
        input_paths.append(input_pred_path+".ivf")
        input_paths.append(pred_state_path+".state")

        output_paths.append(input_path+".ivf")
        if idx != len(segs)-1:
            output_paths.append(output_state_path)

    return input_paths, output_paths


def handler(event):
    input_bucket = event["input_bucket"]
    output_bucket = event["output_bucket"]
    segs = event["segments"]
    segs = [os.path.splitext(seg)[0] for seg in segs]

    tmp_dir = "/tmp"
    download_bin(input_bucket, "xc-enc", tmp_dir)

    data_dir = os.path.join(tmp_dir, str(uuid.uuid4()))
    os.makedirs(data_dir, exist_ok=True)

    input_paths, _ = rebase(segs, data_dir, dry_run=True)
    for path in input_paths:
        file = os.path.basename(path)
        bucket = input_bucket if ".y4m" in file else output_bucket
        print("Downloading", file, "from", bucket)
        try:
            client.download(bucket, file, path)
        except:
            # -1.state is generated by rebase itself
            if not "-1.state" in file:
                raise

    _, output_paths = rebase(segs, data_dir)
    upload_files(output_bucket, output_paths)

    shutil.rmtree(data_dir)
